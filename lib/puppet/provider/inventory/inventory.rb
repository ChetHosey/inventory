require 'puppetx/filemapper'

Puppet::Type.type(:inventory).provide(:inventory) do
  # note that we need to call this before including PuppetX::FileMapper,
  # since the latter will override the property methods.
  mk_resource_methods

  include PuppetX::FileMapper

  # FileMapper's `create` updates @property_hash for properties, but not
  # parameters.
  #
  # Given that the default methods generated by
  # mk_resource_methods *do* update @property_hash for properties,
  # it seems reasonable to populate it too.
  #
  # Why does this matter?
  #
  # If @property_hash doesn't include the parameters,
  # they won't be available from within parse_file for new resources,
  # such as when calling prov.measure. To get the values we'd end up
  # having to conditionally dig into the resource if the provider
  # method returned :absent.
  #
  # Instead we just update @property_hash here and let the original
  # method do the rest.
  def create
    @resource.class.parameters.each do |attr|
      attr = attr.to_sym
      next if attr == :name
      @property_hash[attr] = @resource[attr]
    end

    super
  end

  # Not useful, but it's a demo.
  def self.target_files
    ['/tmp/inv']
  end

  # Not the most complex, but again, it's a demo.
  def self.parse_file(_filename, content)
    lines = content.split("\n")

    results = []
    lines.each do |line|
      n, m, v = line.split(%r{: *})

      results << {
        item: n,
        measure: m,
        quantity: v,
      }
    end
    results
  end

  # Colon-delimit output
  def self.format_file(_filename, providers)
    output = ''
    providers.each do |prov|
      output += "#{prov.item}:#{prov.measure}:#{prov.quantity}\n"
    end
    output
  end

  # All entries go into the same file
  def select_file
    '/tmp/inv'
  end

  def self.prefetch(resources = {})
    providers = instances.each_with_object({}) do |instance, hash|
      # The original implementation gets the value of the first
      # namevar. Instead we generate a uniqueness key for the provider
      # instance, which follows the method used by Puppet to generate
      # the uniqueness key for the resource entry.
      hash[instance.uniqueness_key] = instance
    end

    # Puppet crawls the catalog and keeps a map of resources
    # associated with each provider. The problem is that the
    # resource name is used for the map key, even when the type
    # has a composite namevar.
    #
    # This means that entries with unique sets of namevars but
    # without a unique `name` field will collide, and the
    # `resources` map we receive won't actually include all of
    # our resources from the catalog.
    #
    # So we take the first entry to get a reference to the catalog
    # and use `catalog.vertices.select` to find resources using this
    # provider.
    #
    # See PUP-5302. This approach started with the shown workaround,
    # with some copying from `Puppet::Transaction.resources_by_provider.`
    catalog = resources.values.first.catalog
    catalog_entries = catalog.vertices.select do |resource|
      resource.provider.class == self
    end

    # Having built a list of catalog entries, we now set each entry's
    # provider to the provider corresponding to an entry found in the
    # target file.
    catalog_entries.each do |resource|
      resource.provider = providers[resource.uniqueness_key] if providers[resource.uniqueness_key]
    end
  end

  # This mirrors the uniqueness_key method from Puppet::Type.
  # We get a list of key attributes from the type, sort appropriately,
  # and then call (`send`) the corresponding function on the provider
  # to get the corresponding values.
  def uniqueness_key
    self.class.resource_type.key_attributes.sort_by { |attribute_name| attribute_name.to_s }.map { |attribute_name| send attribute_name }
  end
end
